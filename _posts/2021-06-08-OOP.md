```
title: 객체지향적 프로그래밍(Object Oriented Programming
author: dongee_seo
date: 2021-06-08
categories: [Blogging, Tutorial]
tags: [google analytics, pageviews]
```

# 프로그래밍 패러다임(programming paradaim)

---

### 개념

: 프로그래밍 패러다임에는 함수형, 논리형, 절차형, 객체지향형이 있다. 이들은 선언형과 명령형으로 분류할 수 있다. 이 중 선언형 프로그래밍(Declarative Programming)은 ‘무엇을 할 것인가’와 가깝고,
명령형 프로그래밍(Imperative programming)은 무엇을 ‘어떻게 할 것인가’에 가깝다.

### 명령형 프로그래밍(Imperative programming)

(1) 개념
: 명령형 프로그래밍은 프로그래밍의 상태와 상태를 변경시키는 구문의 과정에서 연산을 설명하는 프로그래밍 패러다임이다.

(2) 명령형 프로그래밍의 특징

첫째, 메모리에 프로그램과 데이터를 넣고 차례로 불러내 처리하는 방식인 “폰노이만 구조"에 개념적인 기초를 두고 있다.

둘째, 순차적인 명령수행으로 기본으로 하고, 문제처리를 위한 작업수행의 알고리즘에 초점을 두고 코드를 작성한다.
![](https://velog.velcdn.com/images%2Fseod0209%2Fpost%2F5c9e2f9c-c9b1-4b47-afda-d479b6f3c6ab%2Fimage.png)
명령형 프로그래밍은 절차적 프로그래밍과 객체지향적 프로그래밍으로 구분할수 있다. 명령형 프로그래밍의 특징인 순차적 진행은알고리즘에 잘 나타난다. 이러한 진행의 방식은 절차적이던 객체지향이던 예외없이 적용된다.

(3) 절차적 프로그래밍(Procedural Programming)
객체지향적 프로그래밍이 왜 나타나게 되었는지를 살펴보기 이전에 절차적 프로그래밍에 대한 이해가 먼저 필요하다.

1. 개념
   : 절차적 프로그래밍이란 입력한 로직에 따라 순서대로 코드가 실행되는 방식으로 프로그램 전체가 유기적으로 연결되도록 하는 프로그래밍 패러다임이다. ex. C언어, FORTRAN 등
2. 특징

#### a. Procedure(프로시저)와 Procedure Call(함수 호출)

: 순차적으로 진행됨에도 불구하고 프로그램 전체가 유기적으로 연결될 수 있는 이유는 바로 프로시저 때문이다. 절차적 프로그래밍은 데이터를 중심으로 프로시저(함수)를 구현한다. 이후 같은 코드를 복사하지 않고 다른 위치에서 프로시저(함수)를 호출하여 사용할수 있게 함으로서 전체가 유기적으로 연결될수 있게 한다.
또한 함수 호출을 통해 여러부분을 생략하여 프로그램 흐름을 쉽게 볼 수 있으므로 코드의 가독성이 높아진다. (절차지향적 프로그래밍은 프로시저를 포함한 함수들이 여러개 모여 하나의 프로그램을 구성한다.)

#### b. Top-Down 방식으로 설계

: 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리. 비교적 작은 규모의 작업을 수행하는 함수(function)을 생성한다. 함수(procedure)단위로 나누어 구조화한다.
모듈화와 구조화가 더 용이해지므로 대규모 프로젝트에 많은 프로그래머들이 투입된 경우 자신이 맡은 부분만 프로그래밍하여 조립하는것도 가능해진다

#### c. 컴퓨터 작업 처리 방식과 유사

때문에 다른 패러다임에 비해 실행속도가 빠르다. 따라서 과학계산이나 하드웨어 제어에 주로 사용된다.

3. 한계점

#1 실행순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

#2 프로그램의 규모가 커질수록 유지관리비용이 대폭 증가한다.
절차적 프로그래밍은 데이터와 함수(메소드)를 별개로 취급한다. 따라서 특정 기능을 수행하려면 그 일을 해주는 메소드를 직접 호출해야한다. 이는 데이터의 상태에 따라 다르게 동작하는 함수들이 많아지게한다.
따라서 각 함수들로 전달되는 변수들이 적절한 값을 갖는지 확인하는 코드가 늘어난다.
그 결과 프로시저(함수)를 호출하는 것은 그냥 코드를 쓰는것보다 시간이 많이 소모하게 된다.

#3 또한 문제가 발생했을 때 함수에 영향을 주는 변수를 추적하는 것이 어려워졌다. 즉, 프로그램에 버그가 있는 경우 원인을 분석하는데 그만큼 많은 시간과 노력이 더 필요해지게 된다.

이러한 문제들을 해결하기 위해 등장한 것이 객체지향 프로그래밍(Object-Oriented Programming) 이다.

# 객체지향적 프로그래밍(Object Oriented Programming)

---

객체(object)란 간단히 이야기하자면 실생활에서 우리가 인식할 수 있는 사물로 설명할 수 있다.
이러한 객체의 상태(state)와 행동(behavior)을 구체화하는 형태의 프로그래밍이 바로 객체 지향 프로그래밍이다.
ex. Java, c++ 등

Java를 중심으로 객체지향 프로그래밍 언어를 살펴보고,
이를 바탕으로 ES6이후 class개념이 도입된 객체지향 스크립트언어인 자바스크립트를 검토해 보겠다.
이 두 언어는 이름이 비슷하지만완전히 다른 언어이다. 그럼에도 불구하고 자바스크립트 또한 살펴보는 이유는
현재 프로젝트를 진행하며 사용하고 있는 React가 ES6 특징을 사용해 만들어졌기 때문이다.
class가 도입된 ES6이후의 자바스크립트 학습을 통해 React 코드와 최근 배운 타입스크립트를 사용하는데 이해도가 높아질것이라고 생가한다.

## 구성요소

: 클래스, 클래스 타입의 객체, 속성, 메서드, 생성자

### 클래스(Class)

클래스는 객체를 만들어 내기 위한 설계도 혹은 틀이다. 공통된 특성과 행위를 갖는 객체의 집합을 의미합니다. 관련 있는것들 끼리 하나로 묶는 개념적(추상적인)주체이고, 자바에서 클래스는상태를 정의하는 필드(fields; 자바스크립트나 다른 언어등에서는 속성)와 동작을 정의하는 메소드(methods) 두 영역으로 나뉜다.

![](https://velog.velcdn.com/images%2Fseod0209%2Fpost%2F36bada10-f853-4afd-9369-27fde86d26b9%2Fimage.png)

: 위 그림은 분석단계의 클래스 다이어그램이다, 일단 고양이라는 이름의 클래스를 만들때
고양이의 특징으로 이름, 고양이의 종류(breeds), 무게또는 크기가 있다. 지금 고양이가 앞발을 들고있다는 행동은 메서드를 의미한다.

![](https://velog.velcdn.com/images%2Fseod0209%2Fpost%2Fb5d502e3-a6c5-4b35-a0d2-0904988b089a%2Fimage.png)
: 앞서 살펴본 클래스 다이어그램의 필드와 메소드를 코드로 옮기면 다음과 같다.
객체의 특징을 의미하는곳은 필드(속성)가 되고, 객체의 행동은 메서드가 된다.

![](https://velog.velcdn.com/images%2Fseod0209%2Fpost%2Fd0f71cb0-13a5-44ec-b9d5-d850625289b4%2Fimage.png)

자바에서 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체(object)를 선언해야 한다.
이렇게 클래스로부터 객체를 선언하는 과정을 ‘클래스의 인스턴스 화’라고 한다.
또한, 이렇게 선언된 해당 ‘클래스 타입의 객체’를 인스턴스(instance)라고 한다.

### 인스턴스의 특징

![](https://velog.velcdn.com/images%2Fseod0209%2Fpost%2Fe0016e25-8eaf-4ae3-ab3e-bc48dd6d966d%2Fimage.png)

- 자바: 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있다.
  변수에 클래스를 저장할 때는 new 키워드를 사용한다.
- 이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드(속성)를 가질 수 있다.
  이렇게 선언된 해당 ‘클래스 타입의 객체’를 인스턴스(instance)라고 한다.
  아! 그리고 메서드의 이름은 사용하는쪽(클라이언트 코드)에 맞게 명명하는게 좋은데
  예를들어 학생의 이름을 불러오는 메서드를 만든다다면 getStudentName이라고 짓는 것을 뜻한다. (서버쪽 입장에서 생각해보면 sendStudnetName이 될 수도 있기 때문이다.)

### 생성자(constructor)

![](https://velog.velcdn.com/images%2Fseod0209%2Fpost%2Fd2993073-5928-4824-899a-18364c643732%2Fimage.png)
//클래스를 만들때는 class 라는 키워드를 사용하고
클래스 안에는 생성자(constructor)가 있다.
자바스크립트는 클래스의 새로운 인스턴스를 만들 때 생성자 메소드를 호출한다.
-(Java Script : 다른언어의(Java 등) 클래스와는 다르다. 상속에 대해 문법적으로 보기 편하게 만든것일 뿐이다.)
//인스턴스는 클래스의 속성과 메서드를 담고 있는 객체이다. 클래스로 만든 객체가 인스턴스라고 생각하면 쉬움
// 위 코드에서 jin은 인스턴스를 담고 있는 변수이다
. 변수에 클래스를 저장할 때는 new 키워드를 사용한다.

## 특징

### 1. 실제 세계를 모델링

: 프로그램을 프로시저보다는 명령과 데이터로 구성된 객체들의 모임으로 표현하는 프로그래밍 패러다임.

### 2. Bottom-Up 방식

큰 문제를 작게 쪼개는 방식이 아니라 작은 문제들을 해결할 수 있는 객체들을 만든 뒤, 이 객체들을 조합해서 큰 문제를 해결하는 방식을 지향한다.

### 3. 객체

: 특정기능을 수행하는 메소드를 가진 객체를 만들어서, 그 인스턴스를 이용해 메소드를호출한다. 객체간 상호작용.
cf. 절차적: 데이터와 함수(메소드)를 별개로 취급한다. 따라서 특정 기능을 수행하려면 그 일을 해주는 메소드를 직접 호출해야한다.

### 4. 자료구조와 이를 중심으로 한 모듈들을 먼저 설계한 다음에, 이들의 실행순서와 흐름을 짜는 방식이고,

cf. 절차적 프로그래밍은 반대로 프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수들을 설계하는 방식이다.

### 5. 실행순서(절차)의 존재

깔끔한 모듈화를 통해서, 단 몇줄의 메소드 호출만으로 구성된 메인함수를 작성할 수도 있도록 도와주는 것은 분명하다. 하지만 그러한 방법으로 코드가 대폭 줄어든 프로그램이라 할 지라도 코드 각 부분의 실행순서는 엄연히 존재한다. 즉 객체지향프로그래밍은 절차를’간소화’해주는 프로그래밍이지, 결코 절차를 무시하는게 아니다.

## 객체지향 표현의 도구:UML(Unified Modeling Language)

### 개념

: uml은 도메인(해결하고자 하는 목표) 을 모델로 표현해주는 대표적인 모델링 언어로 알려져있다.

이런 UML은 소프트웨어를 설계하며 필요에 의해서 사용되는데 일반적으로 아래 3가지의 목적을 가지고 만든다.
• 의사소통 또는 설계 논의를 위해
• 전체 시스템의 구조 및 클래스의 의존성 파악을 위해
• 유지보수를 위한 설계의 back-end 문서 제작을 위해

UML 다이어그램의 종류는 크게 두가지로 구분 할 수 있다.

1. 구조 다이어그램(Structure Diagram)
2. 행위 다이어그램(Behavior Diagram)

### 클래스 다이어그램(Class Diagram)

1. 개념
   : 클래스를 도식화한 것이다. 시간에 따라 변하지 않는 시스템의 정적인 면을 보여주는 정적 다이어그램으로
   클래스의 구성요소 및 클래스간의 관계를 표현한다.

![](https://velog.velcdn.com/images%2Fseod0209%2Fpost%2F106ad0eb-ade3-44b7-9637-3c8122d7790e%2Fimage.png)

- 왼쪽의 그림은 분석단계 클래스: 문제 해결을 위한 도메인 구조를 나타내어
  보이지 않는 도메인 안의 개념과 같은 추상적인 개념을 기술하기 위해 사용된다.
- 오른쪽 그림은 설계단계 클래스: 소프트웨어의 설계 혹은 완성된 소프트웨어의 구현 설명을 목적으로 사용된다.

2. 구성
   클래스는 3가지 칸으로 구성된다.
   가장 윗 부분에는 클래스 명이 들어가고, 중간 부분에는 속성(클래스의 특징, 변수)이 들어갑니다. 마지막 부분에는 연산(메서드, 클래스가 수행하는 책임)이 들어간다.

:: 접근제어자 리스트
• + : public
• - : private
• # : protected : 이 클래스와 동일 패키지에 있거 상속관계에 있는 하위클래의 객체들만 접근가능하다.

:: 속성(Attribute)
o 이름: 타입 = 기본값
o ex) -title: String = ""
• 메서드
o 접근제어자이름(파라미터 속성): 리턴값
o ex_1) +setTitle(String)
o ex_2) +getTitle(): String

클래스 다이어그램은 화살표와 실선으로 관계 표현된다. 화살표를 쏜 클래스가 화살표받는클래스를 상속한다. 단방향(화살표)의 경우 한 쪽은 알지만 다른 쪽은 상대방의 존재를 모른다.

- 양방향(실선)의 경우 두 클래스의 객체들이 서로를 인지한다.

![](https://velog.velcdn.com/images%2Fseod0209%2Fpost%2F6be81d8c-34ec-446b-8e87-89068cabb00c%2Fimage.png)

> 자료출처
> [https://sabarada.tistory.com/72](https://sabarada.tistory.com/72) > [https://ui.dev/imperative-vs-declarative-programming](https://ui.dev/imperative-vs-declarative-programming) > [https://boxfoxs.tistory.com/430](https://boxfoxs.tistory.com/430) > [https://blog.naver.com/whdgml1996/221987818879](https://blog.naver.com/whdgml1996/221987818879) > [https://m.blog.naver.com/atalanta16/220249264429](https://m.blog.naver.com/atalanta16/220249264429) > [https://st-lab.tistory.com/151](https://st-lab.tistory.com/151) > [https://blog.naver.com/whdgml1996/221889374877](https://blog.naver.com/whdgml1996/221889374877) > [https://gracefulprograming.tistory.com/130](https://gracefulprograming.tistory.com/130) > [https://blog.naver.com/whdgml1996/221889374877](https://blog.naver.com/whdgml1996/221889374877) > [https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html](https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html) > [https://devdhjo.github.io/cert/2020/05/06/cert-eip-008.html](https://devdhjo.github.io/cert/2020/05/06/cert-eip-008.html) > [https://edu.goorm.io/learn/lecture/22108/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9E%90%EB%B0%94-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/lesson/1040499/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4](https://edu.goorm.io/learn/lecture/22108/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9E%90%EB%B0%94-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/lesson/1040499/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4)
